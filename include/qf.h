//$file${include::qf.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpc.qm
// File:  ${include::qf.h}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C real-time embedded framework
// Framework(s) : qpc
// Support ends : 2023-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${include::qf.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#ifndef QF_H_
#define QF_H_

//============================================================================
//! @cond INTERNAL

#ifndef QF_MAX_ACTIVE
#define QF_MAX_ACTIVE 32U
#endif

#if (QF_MAX_ACTIVE > 64U)
#error QF_MAX_ACTIVE exceeds the maximum of 64U;
#endif

#ifndef QF_MAX_TICK_RATE
#define QF_MAX_TICK_RATE 1U
#endif

#if (QF_MAX_TICK_RATE > 15U)
#error QF_MAX_TICK_RATE exceeds the maximum of 15U;
#endif

#ifndef QF_MAX_EPOOL
#define QF_MAX_EPOOL 3U
#endif

#if (QF_MAX_EPOOL > 15U)
#error QF_MAX_EPOOL exceeds the maximum of 15U;
#endif

#ifndef QF_TIMEEVT_CTR_SIZE
#define QF_TIMEEVT_CTR_SIZE 4U
#endif

#if (QF_TIMEEVT_CTR_SIZE > 4U)
#error QF_TIMEEVT_CTR_SIZE defined incorrectly, expected 1U, 2U, or 4U;
#endif

#ifndef QF_EVENT_SIZ_SIZE
#define QF_EVENT_SIZ_SIZE 2U
#endif

#if (QF_EVENT_SIZ_SIZE > 4U)
#error QF_EVENT_SIZ_SIZE defined incorrectly, expected 1U, 2U, or 4U;
#endif

//! @endcond
//============================================================================

//$declare${QF-types} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF-types::QTimeEvtCtr} ...................................................
#if (QF_TIMEEVT_CTR_SIZE == 1U)
typedef uint8_t QTimeEvtCtr;
#endif //  (QF_TIMEEVT_CTR_SIZE == 1U)

//${QF-types::QTimeEvtCtr} ...................................................
#if (QF_TIMEEVT_CTR_SIZE == 2U)
typedef uint16_t QTimeEvtCtr;
#endif //  (QF_TIMEEVT_CTR_SIZE == 2U)

//${QF-types::QTimeEvtCtr} ...................................................
#if (QF_TIMEEVT_CTR_SIZE == 4U)
typedef uint32_t QTimeEvtCtr;
#endif //  (QF_TIMEEVT_CTR_SIZE == 4U)

//${QF-types::QPSetBits} .....................................................
#if (QF_MAX_ACTIVE <= 8U)
typedef uint8_t QPSetBits;
#endif //  (QF_MAX_ACTIVE <= 8U)

//${QF-types::QPSetBits} .....................................................
#if (8U < QF_MAX_ACTIVE) && (QF_MAX_ACTIVE <= 16U)
typedef uint16_t QPSetBits;
#endif //  (8U < QF_MAX_ACTIVE) && (QF_MAX_ACTIVE <= 16U)

//${QF-types::QPSetBits} .....................................................
#if (16U < QF_MAX_ACTIVE)
typedef uint32_t QPSetBits;
#endif //  (16U < QF_MAX_ACTIVE)

//${QF-types::QPrioSpec} .....................................................
typedef uint16_t QPrioSpec;

//${QF-types::QF_LOG2} .......................................................
#ifndef QF_LOG2
uint_fast8_t QF_LOG2(QPSetBits const bitmask);
#endif // ndef QF_LOG2

//${QF-types::QPSet} .........................................................
//! @class QPSet
typedef struct {
// private:

    //! @private @memberof QPSet
    QPSetBits bits[(QF_MAX_ACTIVE + (8U*sizeof(QPSetBits)) - 1U)/(8U*sizeof(QPSetBits))];
} QPSet;

// public:

//! @public @memberof QPSet
//! @public @memberof QPSet
static inline void QPSet_setEmpty(QPSet * const me) {
    me->bits[0] = 0U;
    #if (QF_MAX_ACTIVE > 32)
    me->bits[1] = 0U;
    #endif
}

//! @public @memberof QPSet
//! @public @memberof QPSet
static inline bool QPSet_isEmpty(QPSet const * const me) {
    #if (QF_MAX_ACTIVE <= 32U)
    return (me->bits[0] == 0U);
    #else
    return (me->bits[0] == 0U) ? (me->bits[1] == 0U) : false;
    #endif
}

//! @public @memberof QPSet
//! @public @memberof QPSet
static inline bool QPSet_notEmpty(QPSet const * const me) {
    #if (QF_MAX_ACTIVE <= 32U)
    return (me->bits[0] != 0U);
    #else
    return (me->bits[0] != 0U) ? true : (me->bits[1] != 0U);
    #endif
}

//! @public @memberof QPSet
//! @public @memberof QPSet
static inline bool QPSet_hasElement(QPSet const * const me,
    uint_fast8_t const n)
{
    #if (QF_MAX_ACTIVE <= 32U)
    return (me->bits[0] & (1U << (n - 1U))) != 0U;
    #else
    return (n <= 32U)
        ? ((me->bits[0] & ((uint32_t)1U << (n - 1U))) != 0U)
        : ((me->bits[1] & ((uint32_t)1U << (n - 33U))) != 0U);
    #endif
}

//! @public @memberof QPSet
//! @public @memberof QPSet
static inline void QPSet_insert(QPSet * const me,
    uint_fast8_t const n)
{
    #if (QF_MAX_ACTIVE <= 32U)
    me->bits[0] = (me->bits[0] | (1U << (n - 1U)));
    #else
    if (n <= 32U) {
        me->bits[0] = (me->bits[0] | ((uint32_t)1U << (n - 1U)));
    }
    else {
        me->bits[1] = (me->bits[1] | ((uint32_t)1U << (n - 33U)));
    }
    #endif
}

//! @public @memberof QPSet
//! @public @memberof QPSet
static inline void QPSet_remove(QPSet * const me,
    uint_fast8_t const n)
{
    #if (QF_MAX_ACTIVE <= 32U)
    me->bits[0] = (me->bits[0] & (QPSetBits)(~((QPSetBits)1U << (n - 1U))));
    #else
    if (n <= 32U) {
        (me->bits[0] = (me->bits[0] & ~((uint32_t)1U << (n - 1U))));
    }
    else {
        (me->bits[1] = (me->bits[1] & ~((uint32_t)1U << (n - 33U))));
    }
    #endif
}

//! @public @memberof QPSet
//! @public @memberof QPSet
static inline uint_fast8_t QPSet_findMax(QPSet const * const me) {
    #if (QF_MAX_ACTIVE <= 32U)
    return QF_LOG2(me->bits[0]);
    #else
    return (me->bits[1] != 0U)
        ? (QF_LOG2(me->bits[1]) + 32U)
        : (QF_LOG2(me->bits[0]));
    #endif
}

// private:

#ifndef Q_UNSAFE
//! @private @memberof QPSet
//! @private @memberof QPSet
static inline void QPSet_update_(QPSet const * const me,
    QPSet * const dis)
{
    dis->bits[0] = ~me->bits[0];
    #if (QF_MAX_ACTIVE > 32U)
    dis->bits[1] = ~me->bits[1];
    #endif
}
#endif // ndef Q_UNSAFE

#ifndef Q_UNSAFE
//! @private @memberof QPSet
//! @private @memberof QPSet
static inline bool QPSet_verify_(QPSet const * const me,
    QPSet const * const dis)
{
    #if (QF_MAX_ACTIVE <= 32U)
    return me->bits[0] == (QPSetBits)(~dis->bits[0]);
    #else
    return (me->bits[0] == (QPSetBits)(~dis->bits[0]))
           && (me->bits[1] == (QPSetBits)(~dis->bits[1]));
    #endif
}
#endif // ndef Q_UNSAFE

//${QF-types::QSubscrList} ...................................................
// @struct QSubscrList
typedef struct {
// private:

    //! @private @memberof QSubscrList
    QPSet set;

#ifndef Q_UNSAFE
    //! @private @memberof QSubscrList
    QPSet set_dis;
#endif // ndef Q_UNSAFE
} QSubscrList;

//${QF-types::QSchedStatus} ..................................................
typedef uint_fast16_t QSchedStatus;
//$enddecl${QF-types} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QF::QActive} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF::QActive} .............................................................
//! @class QActive
//! @extends QHsm
typedef struct QActive {
// protected:
    QHsm super;

// private:

#ifdef QF_EQUEUE_TYPE
    //! @private @memberof QActive
    QF_EQUEUE_TYPE eQueue;
#endif // def QF_EQUEUE_TYPE

#ifdef QF_OS_OBJECT_TYPE
    //! @private @memberof QActive
    QF_OS_OBJECT_TYPE osObject;
#endif // def QF_OS_OBJECT_TYPE

#ifdef QF_THREAD_TYPE
    //! @private @memberof QActive
    QF_THREAD_TYPE thread;
#endif // def QF_THREAD_TYPE

    //! @private @memberof QActive
    uint8_t prio;

    //! @private @memberof QActive
    uint8_t pthre;
} QActive;

// protected:

//! @protected @memberof QActive
//! @protected @memberof QActive
void QActive_ctor(QActive * const me,
    QStateHandler const initial);

#ifdef QF_ACTIVE_STOP
//! @protected @memberof QActive
//! @protected @memberof QActive
void QActive_stop(QActive * const me);
#endif // def QF_ACTIVE_STOP

//! @protected @memberof QActive
//! @protected @memberof QActive
void QActive_subscribe(QActive const * const me,
    enum_t const sig);

//! @protected @memberof QActive
//! @protected @memberof QActive
void QActive_unsubscribe(QActive const * const me,
    enum_t const sig);

//! @protected @memberof QActive
//! @protected @memberof QActive
void QActive_unsubscribeAll(QActive const * const me);

// public:

//! @static @public @memberof QActive
//! @static @public @memberof QActive
void QActive_psInit(
    QSubscrList * const subscrSto,
    enum_t const maxSignal);

// protected:

//! @protected @memberof QActive
//! @protected @memberof QActive
bool QActive_defer(QActive const * const me,
    QEQueue * const eq,
    QEvt const * const e);

//! @protected @memberof QActive
//! @protected @memberof QActive
bool QActive_recall(QActive * const me,
    QEQueue * const eq);

//! @protected @memberof QActive
//! @protected @memberof QActive
uint_fast16_t QActive_flushDeferred(QActive const * const me,
    QEQueue * const eq);

// public:

//! @public @memberof QActive
//! @public @memberof QActive
void QActive_setAttr(QActive * const me,
    uint32_t attr1,
    void const * attr2);

// private:

//! @private @memberof QActive
//! @private @memberof QActive
void QActive_start_(QActive * const me,
    QPrioSpec const prioSpec,
    QEvt const * * const qSto,
    uint_fast16_t const qLen,
    void * const stkSto,
    uint_fast16_t const stkSize,
    void const * const par);

//! @private @memberof QActive
//! @private @memberof QActive
bool QActive_post_(QActive * const me,
    QEvt const * const e,
    uint_fast16_t const margin,
    void const * const sender);

//! @private @memberof QActive
//! @private @memberof QActive
void QActive_postLIFO_(QActive * const me,
    QEvt const * const e);

//! @private @memberof QActive
//! @private @memberof QActive
QEvt const * QActive_get_(QActive * const me);

//! @static @private @memberof QActive
//! @static @private @memberof QActive
void QActive_publish_(
    QEvt const * const e,
    void const * const sender,
    uint_fast8_t const qs_id);

//! @private @memberof QActive
//! @private @memberof QActive
void QActive_thread_(QActive * const me);

//! @private @memberof QActive
//! @private @memberof QActive
void QActive_register_(QActive * const me);

//! @private @memberof QActive
//! @private @memberof QActive
void QActive_unregister_(QActive * const me);

#ifdef QF_ISR_API
//! @private @memberof QActive
//! @private @memberof QActive
bool QActive_postFromISR_(QActive * const me,
    QEvt const * const e,
    uint_fast16_t const margin,
    void * par,
    void const * const sender);
#endif // def QF_ISR_API

#ifdef QF_ISR_API
//! @private @memberof QActive
//! @private @memberof QActive
void QActive_publishFromISR_(
    QEvt const * e,
    void * par,
    void const * sender);
#endif // def QF_ISR_API

//! @static @private @memberof QActive
extern QSubscrList * QActive_subscrList_;

//! @static @private @memberof QActive
extern enum_t QActive_maxPubSignal_;

//! @static @private @memberof QActive
extern QActive * QActive_registry_[QF_MAX_ACTIVE + 1U];
//$enddecl${QF::QActive} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QF::QMActive} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF::QMActive} ............................................................
//! @class QMActive
// @extends QActive
typedef struct {
// protected:
    QActive super;
} QMActive;

// protected:

//! @protected @memberof QMActive
//! @protected @memberof QMActive
void QMActive_ctor(QMActive * const me,
    QStateHandler const initial);
//$enddecl${QF::QMActive} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QF::QTimeEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF::QTimeEvt} ............................................................
//! @class QTimeEvt
// @extends QEvt
typedef struct QTimeEvt {
// protected:
    QEvt super;

// private:

    //! @private @memberof QTimeEvt
    struct QTimeEvt * volatile next;

    //! @private @memberof QTimeEvt
    void * volatile act;

    //! @private @memberof QTimeEvt
    QTimeEvtCtr volatile ctr;

    //! @private @memberof QTimeEvt
    QTimeEvtCtr interval;
} QTimeEvt;

// public:

//! @public @memberof QTimeEvt
//! @public @memberof QTimeEvt
void QTimeEvt_ctorX(QTimeEvt * const me,
    QActive * const act,
    enum_t const sig,
    uint_fast8_t const tickRate);

//! @public @memberof QTimeEvt
//! @public @memberof QTimeEvt
void QTimeEvt_armX(QTimeEvt * const me,
    QTimeEvtCtr const nTicks,
    QTimeEvtCtr const interval);

//! @public @memberof QTimeEvt
//! @public @memberof QTimeEvt
bool QTimeEvt_disarm(QTimeEvt * const me);

//! @public @memberof QTimeEvt
//! @public @memberof QTimeEvt
bool QTimeEvt_rearm(QTimeEvt * const me,
    QTimeEvtCtr const nTicks);

//! @public @memberof QTimeEvt
//! @public @memberof QTimeEvt
bool QTimeEvt_wasDisarmed(QTimeEvt * const me);

//! @public @memberof QTimeEvt
//! @public @memberof QTimeEvt
QTimeEvtCtr QTimeEvt_currCtr(QTimeEvt const * const me);

//! @static @private @memberof QTimeEvt
//! @static @private @memberof QTimeEvt
void QTimeEvt_tick_(
    uint_fast8_t const tickRate,
    void const * const sender);

// private:

#ifdef Q_UTEST
//! @static @private @memberof QTimeEvt
//! @static @private @memberof QTimeEvt
void QTimeEvt_tick1_(
    uint_fast8_t const tickRate,
    void const * const sender);
#endif // def Q_UTEST

// public:

//! @static @public @memberof QTimeEvt
//! @static @public @memberof QTimeEvt
bool QTimeEvt_noActive(uint_fast8_t const tickRate);

//! @static @private @memberof QTimeEvt
extern QTimeEvt QTimeEvt_timeEvtHead_[QF_MAX_TICK_RATE];
//$enddecl${QF::QTimeEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QF::QTicker} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF::QTicker} .............................................................
//! @class QTicker
// @extends QActive
typedef struct {
// protected:
    QActive super;
} QTicker;

// public:

//! @public @memberof QTicker
//! @public @memberof QTicker
void QTicker_ctor(QTicker * const me,
    uint_fast8_t const tickRate);

// private:

//! @private @memberof QTicker
//! @private @memberof QTicker
void QTicker_init_(
    QHsm * const me,
    void const * const par,
    uint_fast8_t const qs_id);

//! @private @memberof QTicker
//! @private @memberof QTicker
void QTicker_dispatch_(
    QHsm * const me,
    QEvt const * const e,
    uint_fast8_t const qs_id);

//! @private @memberof QTicker
//! @private @memberof QTicker
void QTicker_tick_(
    QActive * const me,
    void const * const sender);
//$enddecl${QF::QTicker} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QF::QF-base} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF::QF-base::init} .......................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
void QF_init(void);

//${QF::QF-base::stop} .......................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
void QF_stop(void);

//${QF::QF-base::run} ........................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
int_t QF_run(void);

//${QF::QF-base::getQueueMin} ................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
uint_fast16_t QF_getQueueMin(uint_fast8_t const prio);

//${QF::QF-base::onStartup} ..................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
void QF_onStartup(void);

//${QF::QF-base::onCleanup} ..................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
void QF_onCleanup(void);

//${QF::QF-base::onContextSw} ................................................
#ifdef QF_ON_CONTEXT_SW
//! @static @public @memberof QF
//! @static @public @memberof QF
void QF_onContextSw(
    QActive * prev,
    QActive * next);
#endif // def QF_ON_CONTEXT_SW
//$enddecl${QF::QF-base} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QF::QF-dyn} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF::QF-dyn::poolInit} ....................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
void QF_poolInit(
    void * const poolSto,
    uint_fast32_t const poolSize,
    uint_fast16_t const evtSize);

//${QF::QF-dyn::poolGetMaxBlockSize} .........................................
//! @static @public @memberof QF
//! @static @public @memberof QF
uint_fast16_t QF_poolGetMaxBlockSize(void);

//${QF::QF-dyn::getPoolMin} ..................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
uint_fast16_t QF_getPoolMin(uint_fast8_t const poolId);

//${QF::QF-dyn::newX_} .......................................................
//! @static @private @memberof QF
//! @static @private @memberof QF
QEvt * QF_newX_(
    uint_fast16_t const evtSize,
    uint_fast16_t const margin,
    enum_t const sig);

//${QF::QF-dyn::gc} ..........................................................
//! @static @public @memberof QF
//! @static @public @memberof QF
void QF_gc(QEvt const * const e);

//${QF::QF-dyn::newRef_} .....................................................
//! @static @private @memberof QF
//! @static @private @memberof QF
QEvt const * QF_newRef_(
    QEvt const * const e,
    void const * const evtRef);

//${QF::QF-dyn::deleteRef_} ..................................................
//! @static @private @memberof QF
//! @static @private @memberof QF
void QF_deleteRef_(void const * const evtRef);
//$enddecl${QF::QF-dyn} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QF-macros} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF-macros::QF_NO_MARGIN} .................................................
#define QF_NO_MARGIN ((uint_fast16_t)0xFFFFU)

//${QF-macros::Q_PRIO} .......................................................
#define Q_PRIO(prio_, pthre_) ((QPrioSpec)((prio_) | ((pthre_) << 8U)))

//${QF-macros::Q_NEW} ........................................................
#ifndef Q_EVT_CTOR
#define Q_NEW(evtT_, sig_) ((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
                           QF_NO_MARGIN, (enum_t)(sig_)))
#endif // ndef Q_EVT_CTOR

//${QF-macros::Q_NEW} ........................................................
#ifdef Q_EVT_CTOR
#define Q_NEW(evtT_, sig_, ...) \
    (evtT_##_ctor((evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
                  QF_NO_MARGIN, (sig_)), (enum_t)(sig_), ##__VA_ARGS__))
#endif // def Q_EVT_CTOR

//${QF-macros::Q_NEW_X} ......................................................
#ifndef Q_EVT_CTOR
#define Q_NEW_X(e_, evtT_, margin_, sig_) ((e_) =   \
    (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
                      (margin_), (enum_t)(sig_)))
#endif // ndef Q_EVT_CTOR

//${QF-macros::Q_NEW_X} ......................................................
#ifdef Q_EVT_CTOR
#define Q_NEW_X(e_, evtT_, margin_, sig_, ...) do { \
    (e_) = (evtT_ *)QF_newX_((uint_fast16_t)sizeof(evtT_), \
                             (margin_), (enum_t)(sig_));\
    if ((e_) != (evtT_ *)0) { \
        evtT_##_ctor((e_), (enum_t)(sig_), ##__VA_ARGS__); \
    } \
 } while (false)
#endif // def Q_EVT_CTOR

//${QF-macros::Q_NEW_REF} ....................................................
#define Q_NEW_REF(evtRef_, evtT_) \
    ((evtRef_) = (evtT_ const *)QF_newRef_(e, (evtRef_)))

//${QF-macros::Q_DELETE_REF} .................................................
#define Q_DELETE_REF(evtRef_) do { \
    QF_deleteRef_((evtRef_)); \
    (evtRef_) = (void *)0; \
} while (false)

//${QF-macros::QACTIVE_START} ................................................
#define QACTIVE_START(me_, prioSpec_, qSto_, qLen_, stkSto_, stkSize_, par_) \
    (QActive_start_((QActive *)(me_), (prioSpec_), \
        (qSto_), (qLen_), (stkSto_), (stkSize_), (par_)))

//${QF-macros::QACTIVE_POST} .................................................
#ifdef Q_SPY
#define QACTIVE_POST(me_, e_, sender_) \
    ((void)QActive_post_((me_), (e_), QF_NO_MARGIN, (sender_)))
#endif // def Q_SPY

//${QF-macros::QACTIVE_POST} .................................................
#ifndef Q_SPY
#define QACTIVE_POST(me_, e_, dummy) \
    ((void)QActive_post_((me_), (e_), QF_NO_MARGIN, (void *)0))
#endif // ndef Q_SPY

//${QF-macros::QACTIVE_POST_X} ...............................................
#ifdef Q_SPY
#define QACTIVE_POST_X(me_, e_, margin_, sender_) \
    (QActive_post_((me_), (e_), (margin_), (sender_)))
#endif // def Q_SPY

//${QF-macros::QACTIVE_POST_X} ...............................................
#ifndef Q_SPY
#define QACTIVE_POST_X(me_, e_, margin_, dummy) \
    (QActive_post_((me_), (e_), (margin_), (void *)0))
#endif // ndef Q_SPY

//${QF-macros::QACTIVE_POST_LIFO} ............................................
#define QACTIVE_POST_LIFO(me_, e_) \
    (QActive_postLIFO_((me_), (e_)))

//${QF-macros::QACTIVE_PUBLISH} ..............................................
#ifdef Q_SPY
#define QACTIVE_PUBLISH(e_, sender_) \
    (QActive_publish_((e_), (void const *)(sender_), (sender_)->prio))
#endif // def Q_SPY

//${QF-macros::QACTIVE_PUBLISH} ..............................................
#ifndef Q_SPY
#define QACTIVE_PUBLISH(e_, dummy) (QActive_publish_((e_), (void *)0, 0U))
#endif // ndef Q_SPY

//${QF-macros::QTIMEEVT_TICK_X} ..............................................
#ifdef Q_SPY
#define QTIMEEVT_TICK_X(tickRate_, sender_) \
    (QTimeEvt_tick_((tickRate_), (sender_)))
#endif // def Q_SPY

//${QF-macros::QTIMEEVT_TICK_X} ..............................................
#ifndef Q_SPY
#define QTIMEEVT_TICK_X(tickRate_, dummy) \
    (QTimeEvt_tick_((tickRate_), (void *)0))
#endif // ndef Q_SPY

//${QF-macros::QTIMEEVT_TICK} ................................................
#define QTIMEEVT_TICK(sender_) QTIMEEVT_TICK_X(0U, (sender_))

//${QF-macros::QTICKER_TICK} .................................................
#ifdef Q_SPY
#define QTICKER_TICK(ticker_, sender_) \
    (QTicker_tick_((ticker_), (sender_)))
#endif // def Q_SPY

//${QF-macros::QTICKER_TICK} .................................................
#ifndef Q_SPY
#define QTICKER_TICK(ticker_, sender_) \
    (QTicker_tick_((ticker_), (void *)0))
#endif // ndef Q_SPY

//${QF-macros::QF_CRIT_EXIT_NOP} .............................................
#ifndef QF_CRIT_EXIT_NOP
#define QF_CRIT_EXIT_NOP() ((void)0)
#endif // ndef QF_CRIT_EXIT_NOP

//${QF-macros::QF_TICK_X} ....................................................
#define QF_TICK_X(tickRate_, sender_) QTIMEEVT_TICK_X((tickRate_), (sender_))

//${QF-macros::QF_TICK} ......................................................
#define QF_TICK(sender_) QTIMEEVT_TICK(sender_)

//${QF-macros::QF_PUBLISH} ...................................................
#define QF_PUBLISH(e_, sender_) QACTIVE_PUBLISH((e_), (sender_))

//${QF-macros::QF_MEM_SYS_} ..................................................
#ifndef QF_MEM_SYS_
#define QF_MEM_SYS_() ((void)0)
#endif // ndef QF_MEM_SYS_

//${QF-macros::QF_MEM_APP_} ..................................................
#ifndef QF_MEM_APP_
#define QF_MEM_APP_() ((void)0)
#endif // ndef QF_MEM_APP_
//$enddecl${QF-macros} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

#endif // QF_H_
