//$file${include::qep.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpc.qm
// File:  ${include::qep.h}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C real-time embedded framework
// Framework(s) : qpc
// Support ends : 2023-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${include::qep.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#ifndef QEP_H_
#define QEP_H_

//============================================================================
#define QP_VERSION     730U
#define QP_VERSION_STR "7.3.0"
#define QP_RELEASE     0x7688A4C5U

//============================================================================
//! @cond INTERNAL

#ifndef Q_SIGNAL_SIZE
#define Q_SIGNAL_SIZE 2U
#endif // ndef Q_SIGNAL_SIZE

//! @endcond
//============================================================================

//$declare${glob-types} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${glob-types::int_t} .......................................................
typedef int int_t;

//${glob-types::enum_t} ......................................................
typedef int enum_t;

//${glob-types::float32_t} ...................................................
typedef float float32_t;

//${glob-types::float64_t} ...................................................
typedef double float64_t;
//$enddecl${glob-types} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QEP} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QEP::QP_versionStr[8]} ...................................................
//! the current QP version number string in ROM, based on #QP_VERSION_STR
extern char const QP_versionStr[8];

//${QEP::QSignal} ............................................................
#if (Q_SIGNAL_SIZE == 1U)
typedef uint8_t QSignal;
#endif //  (Q_SIGNAL_SIZE == 1U)

//${QEP::QSignal} ............................................................
#if (Q_SIGNAL_SIZE == 2U)
typedef uint16_t QSignal;
#endif //  (Q_SIGNAL_SIZE == 2U)

//${QEP::QSignal} ............................................................
#if (Q_SIGNAL_SIZE == 4U)
typedef uint32_t QSignal;
#endif //  (Q_SIGNAL_SIZE == 4U)

//${QEP::QEVT_MARKER} ........................................................
#define QEVT_MARKER 0xE0U

//${QEP::QEvt} ...............................................................
// ! @class QEvt
typedef struct {
// public:

    //! @public @memberof QEvt
    QSignal sig;

// private:

    //! @private @memberof QEvt
    uint8_t poolId_;

    //! @private @memberof QEvt
    uint8_t volatile refCtr_;
} QEvt;

// public:

//! @public @memberof QEvt
//! @public @memberof QEvt
static inline void QEvt_ctor(QEvt * const me,
    enum_t const sig)
{
    me->sig     = (QSignal)sig;
    me->poolId_ = QEVT_MARKER;
    me->refCtr_ = 0U;
}

//! @private @memberof QEvt
//! @private @memberof QEvt
static inline bool QEvt_verify_(QEvt const * const me) {
    return (me != (QEvt const *)0)
           && ((me->poolId_ & 0xF0U) == QEVT_MARKER);
}

//${QEP::QStateRet} ..........................................................
//! All possible values returned from state/action handlers
//! @note
//! The order of enumeration matters for algorithmic correctness.
enum QStateRet {
    // unhandled and need to "bubble up"
    Q_RET_SUPER,     //!< event passed to superstate to handle
    Q_RET_SUPER_SUB, //!< event passed to submachine superstate
    Q_RET_UNHANDLED, //!< event unhandled due to a guard

    // handled and do not need to "bubble up"
    Q_RET_HANDLED,   //!< event handled (internal transition)
    Q_RET_IGNORED,   //!< event silently ignored (bubbled up to top)

    // entry/exit
    Q_RET_ENTRY,     //!< state entry action executed
    Q_RET_EXIT,      //!< state exit  action executed

    // no side effects
    Q_RET_NULL,      //!< return value without any effect

    // transitions need to execute transition-action table in ::QMsm
    Q_RET_TRAN,      //!< regular transition
    Q_RET_TRAN_INIT, //!< initial transition in a state or submachine
    Q_RET_TRAN_EP,   //!< entry-point transition into a submachine

    // transitions that additionally clobber me->state
    Q_RET_TRAN_HIST, //!< transition to history of a given state
    Q_RET_TRAN_XP    //!< exit-point transition out of a submachine
};

//${QEP::QState} .............................................................
typedef enum QStateRet QState;

//${QEP::QStateHandler} ......................................................
typedef QState (* QStateHandler )(void * const me, QEvt const * const e);

//${QEP::QActionHandler} .....................................................
typedef QState (* QActionHandler )(void * const me);

//${QEP::QXThread} ...........................................................
// forward declaration
struct QXThread;

//${QEP::QXThreadHandler} ....................................................
typedef void (* QXThreadHandler )(struct QXThread * const me);

//${QEP::QMState} ............................................................
typedef struct QMState {
    struct QMState const *superstate; //!< superstate of this state
    QStateHandler const stateHandler; //!< state handler function
    QActionHandler const entryAction; //!< entry action handler function
    QActionHandler const exitAction;  //!< exit action handler function
    QActionHandler const initAction;  //!< init action handler function
} QMState;

//${QEP::QMTranActTable} .....................................................
typedef struct QMTranActTable {
    QMState const *target;       //!< target of the transition
    QActionHandler const act[1]; //!< array of actions
} QMTranActTable;

//${QEP::QHsmAttr} ...........................................................
union QHsmAttr {
    QStateHandler   fun;         //!< @private @memberof QHsmAttr
    QActionHandler  act;         //!< @private @memberof QHsmAttr
    QXThreadHandler thr;         //!< @private @memberof QHsmAttr
    QMTranActTable const *tatbl; //!< @private @memberof QHsmAttr
    struct QMState const *obj;   //!< @private @memberof QHsmAttr
#ifndef Q_UNSAFE
    uintptr_t      uint;         //!< @private @memberof QHsmAttr
#endif
};

//${QEP::QReservedSig} .......................................................
//! Reserved signals by the QHsm-style state machine implementation
enum QReservedSig {
    Q_EMPTY_SIG,     //!< signal to execute the default case
    Q_ENTRY_SIG,     //!< signal for coding entry actions
    Q_EXIT_SIG,      //!< signal for coding exit actions
    Q_INIT_SIG,      //!< signal for coding initial transitions
    Q_USER_SIG       //!< offset for the user signals (QP Application)
};

//${QEP::QHsm} ...............................................................
//! @class QHsm
typedef struct {
// private:

    //! @protected @memberof QHsm
    struct QHsmVtable const * vptr;

// protected:

    //! @protected @memberof QHsm
    union QHsmAttr state;

    //! @protected @memberof QHsm
    union QHsmAttr temp;
} QHsm;

// protected:

//! @protected @memberof QHsm
//! @protected @memberof QHsm
void QHsm_ctor(QHsm * const me,
    QStateHandler const initial);

// private:

//! @private @memberof QHsm
//! @private @memberof QHsm
void QHsm_init_(QHsm * const me,
    void const * const e,
    uint_fast8_t const qs_id);

//! @private @memberof QHsm
//! @private @memberof QHsm
void QHsm_dispatch_(QHsm * const me,
    QEvt const * const e,
    uint_fast8_t const qs_id);

// public:

//! @public @memberof QHsm
//! @public @memberof QHsm
bool QHsm_isIn(QHsm * const me,
    QStateHandler const state);

//! @public @memberof QHsm
//! @public @memberof QHsm
static inline QStateHandler QHsm_state(QHsm * const me) {
    return me->state.fun;
}

//! @public @memberof QHsm
//! @public @memberof QHsm
QStateHandler QHsm_childState(QHsm * const me,
    QStateHandler const parent);

// private:

#ifdef Q_SPY
//! @private @memberof QHsm
//! @private @memberof QHsm
QStateHandler QHsm_getStateHandler_(QHsm * const me);
#endif // def Q_SPY

// protected:

//! @protected @memberof QHsm
//! @protected @memberof QHsm
QState QHsm_top(QHsm const * const me,
    QEvt const * const e);

// private:

//! @private @memberof QHsm
//! @private @memberof QHsm
int_fast8_t QHsm_tran_(QHsm * const me,
    QStateHandler * const path,
    uint_fast8_t const qs_id);

//! @private @memberof QHsm
//! @private @memberof QHsm
void QHsm_state_entry_(QHsm * const me,
    QStateHandler const state,
    uint_fast8_t const qs_id);

//! @private @memberof QHsm
//! @private @memberof QHsm
bool QHsm_state_exit_(QHsm * const me,
    QStateHandler const state,
    uint_fast8_t const qs_id);

//${QEP::QHsmVtable} .........................................................
struct QHsmVtable {
    void (*init)(QHsm * const me, void const * const e,
                 uint_fast8_t const qs_id);
    void (*dispatch)(QHsm * const me, QEvt const * const e,
                     uint_fast8_t const qs_id);
#ifdef Q_SPY
    QStateHandler (*getStateHandler)(QHsm * const me);
#endif // Q_SPY
};

//${QEP::QMsm} ...............................................................
//! @class QMsm
//! @extends QHsm
typedef struct {
// protected:
    QHsm super;
} QMsm;

// protected:

//! @protected @memberof QMsm
//! @protected @memberof QMsm
void QMsm_ctor(QMsm * const me,
    QStateHandler const initial);

// public:

//! @private @memberof QMsm
//! @private @memberof QMsm
void QMsm_init_(
    QHsm * const me,
    void const * const e,
    uint_fast8_t const qs_id);

// private:

//! @private @memberof QMsm
//! @private @memberof QMsm
void QMsm_dispatch_(
    QHsm * const me,
    QEvt const * const e,
    uint_fast8_t const qs_id);

// public:

//! @public @memberof QMsm
//! @public @memberof QMsm
bool QMsm_isInState(QMsm const * const me,
    QMState const * const state);

//! @public @memberof QMsm
//! @public @memberof QMsm
QMState const * QMsm_childStateObj(
    QHsm const * const me,
    QMState const * const parent);

//! @public @memberof QMsm
//! @public @memberof QMsm
static inline QMState const * QMsm_stateObj(QHsm const * const me) {
    return me->state.obj;
}

#ifdef Q_SPY
//! @public @memberof QMsm
//! @public @memberof QMsm
static inline QStateHandler QMsm_getStateHandler_(QHsm * const me) {
    return me->state.obj->stateHandler;
}
#endif // def Q_SPY

// private:

//! @private @memberof QMsm
//! @private @memberof QMsm
QState QMsm_execTatbl_(
    QHsm * const me,
    QMTranActTable const * const tatbl,
    uint_fast8_t const qs_id);

//! @private @memberof QMsm
//! @private @memberof QMsm
void QMsm_exitToTranSource_(
    QHsm * const me,
    QMState const * const cs,
    QMState const * const ts,
    uint_fast8_t const qs_id);

//! @private @memberof QMsm
//! @private @memberof QMsm
QState QMsm_enterHistory_(
    QHsm * const me,
    QMState const *const hist,
    uint_fast8_t const qs_id);
//$enddecl${QEP} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QEP-macros} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QEP-macros::QEVT_INITIALIZER} ............................................
#define QEVT_INITIALIZER(sig_) { (QSignal)(sig_), QEVT_MARKER, 0U }

//${QEP-macros::QEVT_POOLID_} ................................................
#define QEVT_POOLID_(e_) ((uint_fast8_t)(e_)->poolId_ & 0x0FU)

//${QEP-macros::QHSM_INIT} ...................................................
#ifdef Q_SPY
#define QHSM_INIT(me_, par_, qs_id_) do { \
    Q_ASSERT((me_)->vptr); \
    (*(me_)->vptr->init)((me_), (par_), (qs_id_)); \
} while (false)
#endif // def Q_SPY

//${QEP-macros::QHSM_INIT} ...................................................
#ifndef Q_SPY
#define QHSM_INIT(me_, par_, dummy) do { \
    Q_ASSERT((me_)->vptr); \
    (*(me_)->vptr->init)((me_), (par_), 0U); \
} while (false)
#endif // ndef Q_SPY

//${QEP-macros::QHSM_DISPATCH} ...............................................
#ifdef Q_SPY
#define QHSM_DISPATCH(me_, e_, qs_id_) \
    ((*(me_)->vptr->dispatch)((me_), (e_), (qs_id_)))
#endif // def Q_SPY

//${QEP-macros::QHSM_DISPATCH} ...............................................
#ifndef Q_SPY
#define QHSM_DISPATCH(me_, e_, dummy) \
    ((*(me_)->vptr->dispatch)((me_), (e_), 0U))
#endif // ndef Q_SPY

//${QEP-macros::Q_HSM_UPCAST} ................................................
#define Q_HSM_UPCAST(ptr_) ((QHsm *)(ptr_))

//${QEP-macros::Q_TRAN} ......................................................
#define Q_TRAN(target_) \
    ((Q_HSM_UPCAST(me))->temp.fun = Q_STATE_CAST(target_), \
     (QState)Q_RET_TRAN)

//${QEP-macros::Q_TRAN_HIST} .................................................
#define Q_TRAN_HIST(hist_) \
    ((Q_HSM_UPCAST(me))->temp.fun = (hist_), \
     (QState)Q_RET_TRAN_HIST)

//${QEP-macros::Q_SUPER} .....................................................
#define Q_SUPER(super_) \
    ((Q_HSM_UPCAST(me))->temp.fun = Q_STATE_CAST(super_), \
     (QState)Q_RET_SUPER)

//${QEP-macros::Q_HANDLED} ...................................................
#define Q_HANDLED() ((QState)Q_RET_HANDLED)

//${QEP-macros::Q_UNHANDLED} .................................................
#define Q_UNHANDLED() ((QState)Q_RET_UNHANDLED)

//${QEP-macros::Q_ACTION_NULL} ...............................................
#define Q_ACTION_NULL ((QActionHandler)0)

//${QEP-macros::Q_EVT_CAST} ..................................................
#define Q_EVT_CAST(class_) ((class_ const *)(e))

//${QEP-macros::Q_STATE_CAST} ................................................
#define Q_STATE_CAST(handler_) ((QStateHandler)(handler_))

//${QEP-macros::Q_ACTION_CAST} ...............................................
#define Q_ACTION_CAST(action_) ((QActionHandler)(action_))

//${QEP-macros::Q_UNUSED_PAR} ................................................
#define Q_UNUSED_PAR(par_) ((void)(par_))

//${QEP-macros::Q_DIM} .......................................................
#define Q_DIM(array_) (sizeof(array_) / sizeof((array_)[0U]))

//${QEP-macros::Q_UINT2PTR_CAST} .............................................
#define Q_UINT2PTR_CAST(type_, uint_) ((type_ *)(uint_))

//${QEP-macros::QM_ENTRY} ....................................................
#ifdef Q_SPY
#define QM_ENTRY(state_) \
    ((Q_HSM_UPCAST(me))->temp.obj = (state_), \
     (QState)Q_RET_ENTRY)
#endif // def Q_SPY

//${QEP-macros::QM_ENTRY} ....................................................
#ifndef Q_SPY
#define QM_ENTRY(dummy) ((QState)Q_RET_ENTRY)
#endif // ndef Q_SPY

//${QEP-macros::QM_EXIT} .....................................................
#ifdef Q_SPY
#define QM_EXIT(state_) \
    ((Q_HSM_UPCAST(me))->temp.obj = (state_), \
     (QState)Q_RET_EXIT)
#endif // def Q_SPY

//${QEP-macros::QM_EXIT} .....................................................
#ifndef Q_SPY
#define QM_EXIT(dummy) ((QState)Q_RET_EXIT)
#endif // ndef Q_SPY

//${QEP-macros::QM_SM_EXIT} ..................................................
#define QM_SM_EXIT(state_) \
    ((Q_HSM_UPCAST(me))->temp.obj = (state_), \
     (QState)Q_RET_EXIT)

//${QEP-macros::QM_TRAN} .....................................................
#define QM_TRAN(tatbl_) ((Q_HSM_UPCAST(me))->temp.tatbl \
    = (struct QMTranActTable const *)(tatbl_), \
 (QState)Q_RET_TRAN)

//${QEP-macros::QM_TRAN_INIT} ................................................
#define QM_TRAN_INIT(tatbl_) ((Q_HSM_UPCAST(me))->temp.tatbl \
    = (struct QMTranActTable const *)(tatbl_), \
 (QState)Q_RET_TRAN_INIT)

//${QEP-macros::QM_TRAN_HIST} ................................................
#define QM_TRAN_HIST(history_, tatbl_) \
    ((((Q_HSM_UPCAST(me))->state.obj  = (history_)), \
      ((Q_HSM_UPCAST(me))->temp.tatbl = \
          (struct QMTranActTable const *)(tatbl_))), \
     (QState)Q_RET_TRAN_HIST)

//${QEP-macros::QM_TRAN_EP} ..................................................
#define QM_TRAN_EP(tatbl_) ((Q_HSM_UPCAST(me))->temp.tatbl \
    = (struct QMTranActTable const *)(tatbl_), \
 (QState)Q_RET_TRAN_EP)

//${QEP-macros::QM_TRAN_XP} ..................................................
#define QM_TRAN_XP(xp_, tatbl_) \
    ((((Q_HSM_UPCAST(me))->state.act  = (xp_)), \
      ((Q_HSM_UPCAST(me))->temp.tatbl = \
          (struct QMTranActTable const *)(tatbl_))), \
     (QState)Q_RET_TRAN_XP)

//${QEP-macros::QM_HANDLED} ..................................................
#define QM_HANDLED() ((QState)Q_RET_HANDLED)

//${QEP-macros::QM_UNHANDLED} ................................................
#define QM_UNHANDLED() ((QState)Q_RET_UNHANDLED)

//${QEP-macros::QM_SUPER} ....................................................
#define QM_SUPER() ((QState)Q_RET_SUPER)

//${QEP-macros::QM_SUPER_SUB} ................................................
#define QM_SUPER_SUB(host_) \
    ((Q_HSM_UPCAST(me))->temp.obj = (host_), \
     (QState)Q_RET_SUPER_SUB)

//${QEP-macros::QM_STATE_NULL} ...............................................
#define QM_STATE_NULL ((QMState *)0)
//$enddecl${QEP-macros} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

#endif // QEP_H_
