//$file${include::qxk.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpc.qm
// File:  ${include::qxk.h}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C real-time embedded framework
// Framework(s) : qpc
// Support ends : 2023-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${include::qxk.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//! @file
//! @brief QXK/C (preemptive dual-mode kernel) platform-independent
//! public interface.
//!
//! @trace
//! - @tr{DVP-QP-MC4-D04_08}
#ifndef QXK_H_
#define QXK_H_

//============================================================================
// QF configuration for QXK -- data members of the QActive class...

// QXK event-queue type used for AOs and eXtended threads.
#define QF_EQUEUE_TYPE     QEQueue

// QXK OS-Object type used for the private stack pointer for eXtended threads.
// (The private stack pointer is NULL for basic-threads).
#define QF_OS_OBJECT_TYPE  void*

//============================================================================
#include "qequeue.h"  // QXK kernel uses the native QP event queue
#include "qmpool.h"   // QXK kernel uses the native QP memory pool
#include "qf.h"       // QF framework integrates directly with QXK

//============================================================================
//$declare${QXK::QXK} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QXK::QXK} ................................................................
//! @class QXK
typedef struct {
// private:

    //! @private @memberof QXK
    struct QActive * volatile curr;

    //! @private @memberof QXK
    struct QActive * volatile next;

    //! @private @memberof QXK
    struct QActive * volatile prev;

    //! @private @memberof QXK
    uint8_t volatile actPrio;

    //! @private @memberof QXK
    uint8_t volatile lockCeil;

    //! @private @memberof QXK
    uint8_t volatile lockHolder;

    //! @private @memberof QXK
    QPSet readySet;

#ifndef Q_UNSAFE
    //! @private @memberof QXK
    QPSet readySet_dis;
#endif // ndef Q_UNSAFE
} QXK;
//$enddecl${QXK::QXK} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QXK::QXK-base} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QXK::QXK-base::priv_} ....................................................
//! @static @private @memberof QXK
extern QXK QXK_priv_;

//${QXK::QXK-base::onIdle} ...................................................
//! @static @public @memberof QXK
//! @static @public @memberof QXK
void QXK_onIdle(void);

//${QXK::QXK-base::schedLock} ................................................
//! @static @public @memberof QXK
//! @static @public @memberof QXK
QSchedStatus QXK_schedLock(uint_fast8_t const ceiling);

//${QXK::QXK-base::schedUnlock} ..............................................
//! @static @public @memberof QXK
//! @static @public @memberof QXK
void QXK_schedUnlock(QSchedStatus const stat);

//${QXK::QXK-base::Timeouts} .................................................
//! @static @private @memberof QXK
enum QXK_Timeouts {
    QXK_DELAY_SIG = 1,
    QXK_TIMEOUT_SIG
};

//${QXK::QXK-base::current} ..................................................
//! @static @public @memberof QXK
//! @static @public @memberof QXK
QActive * QXK_current(void);

//${QXK::QXK-base::sched_} ...................................................
//! @static @private @memberof QXK
//! @static @private @memberof QXK
uint_fast8_t QXK_sched_(void);

//${QXK::QXK-base::activate_} ................................................
//! @static @private @memberof QXK
//! @static @private @memberof QXK
void QXK_activate_(void);

//${QXK::QXK-base::stackInit_} ...............................................
//! @static @private @memberof QXK
//! @static @private @memberof QXK
void QXK_stackInit_(
    void * thr,
     QXThreadHandler const handler,
    void * const stkSto,
    uint_fast16_t const stkSize);

//${QXK::QXK-base::contextSw_} ...............................................
//! @static @public @memberof QXK
//! @static @public @memberof QXK
void QXK_contextSw_(QActive * const next);
//$enddecl${QXK::QXK-base} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QXK::QXThread} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QXK::QXThread} ...........................................................
//! @class QXThread
//! @extends QActive
typedef struct QXThread {
// protected:
    QActive super;

// private:

    //! @private @memberof QXThread
    QTimeEvt timeEvt;
} QXThread;

// public:

//! @public @memberof QXThread
//! @public @memberof QXThread
void QXThread_ctor(QXThread * const me,
    QXThreadHandler const handler,
    uint_fast8_t const tickRate);

//! @public @memberof QXThread
//! @public @memberof QXThread
bool QXThread_delay(uint_fast16_t const nTicks);

//! @public @memberof QXThread
//! @public @memberof QXThread
bool QXThread_delayCancel(QXThread * const me);

//! @static @public @memberof QXThread
//! @static @public @memberof QXThread
QEvt const * QXThread_queueGet(uint_fast16_t const nTicks);

// private:

//! @private @memberof QXThread
//! @private @memberof QXThread
void QXThread_start_(
    QActive * const me,
    QPrioSpec const prioSpec,
    QEvt const * * const qSto,
    uint_fast16_t const qLen,
    void * const stkSto,
    uint_fast16_t const stkSize,
    void const * const par);

//! @private @memberof QXThread
//! @private @memberof QXThread
void QXThread_block_(QXThread const * const me);

//! @private @memberof QXThread
//! @private @memberof QXThread
void QXThread_unblock_(QXThread const * const me);

//! @private @memberof QXThread
//! @private @memberof QXThread
void QXThread_timeout_(QActive * const act);

//! @private @memberof QXThread
//! @private @memberof QXThread
void QXThread_teArm_(QXThread * const me,
    enum_t const sig,
    uint_fast16_t const nTicks);

//! @private @memberof QXThread
//! @private @memberof QXThread
bool QXThread_teDisarm_(QXThread * const me);

//! @static @private @memberof QXThread
extern QXThread const * QXThread_dummy;
//$enddecl${QXK::QXThread} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QXK::QXSemaphore} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QXK::QXSemaphore} ........................................................
//! @class QXSemaphore
typedef struct {
// private:

    //! @private @memberof QXSemaphore
    QPSet waitSet;

    //! @private @memberof QXSemaphore
    uint8_t volatile count;

    //! @private @memberof QXSemaphore
    uint8_t max_count;
} QXSemaphore;

// public:

//! @public @memberof QXSemaphore
//! @public @memberof QXSemaphore
void QXSemaphore_init(QXSemaphore * const me,
    uint_fast8_t const count,
    uint_fast8_t const max_count);

//! @public @memberof QXSemaphore
//! @public @memberof QXSemaphore
bool QXSemaphore_wait(QXSemaphore * const me,
    uint_fast16_t const nTicks);

//! @public @memberof QXSemaphore
//! @public @memberof QXSemaphore
bool QXSemaphore_tryWait(QXSemaphore * const me);

//! @public @memberof QXSemaphore
//! @public @memberof QXSemaphore
bool QXSemaphore_signal(QXSemaphore * const me);
//$enddecl${QXK::QXSemaphore} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QXK::QXMutex} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QXK::QXMutex} ............................................................
//! @class QXMutex
typedef struct {
// private:

    //! @private @memberof QXMutex
    QActive ao;

    //! @private @memberof QXMutex
    QPSet waitSet;
} QXMutex;

// public:

//! @public @memberof QXMutex
//! @public @memberof QXMutex
void QXMutex_init(QXMutex * const me,
    QPrioSpec const prioSpec);

//! @public @memberof QXMutex
//! @public @memberof QXMutex
bool QXMutex_lock(QXMutex * const me,
    uint_fast16_t const nTicks);

//! @public @memberof QXMutex
//! @public @memberof QXMutex
bool QXMutex_tryLock(QXMutex * const me);

//! @public @memberof QXMutex
//! @public @memberof QXMutex
void QXMutex_unlock(QXMutex * const me);
//$enddecl${QXK::QXMutex} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QXK-macros} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QXK-macros::QXTHREAD_START} ..............................................
#define QXTHREAD_START(me_, prioSpec_, qSto_, qLen_, stkSto_, stkSize_, par_) \
    (QXThread_start_(&(me_)->super, (prioSpec_), \
        (QEvt const **)(qSto_), (qLen_), \
        (stkSto_), (stkSize_), (par_)))

//${QXK-macros::QXTHREAD_NO_TIMEOUT} .........................................
#define QXTHREAD_NO_TIMEOUT ((uint_fast16_t)0)

//${QXK-macros::QXTHREAD_POST_X} .............................................
#define QXTHREAD_POST_X(me_, e_, margin_, sender_) \
    QACTIVE_POST_X(&(me_)->super, (e_), (margin_), (sender_))
//$enddecl${QXK-macros} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//============================================================================
// interface used only inside QP implementation, but not in applications
#ifdef QP_IMPL

//$declare${QXK-impl} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QXK-impl::QF_SCHED_STAT_} ................................................
#define QF_SCHED_STAT_ QSchedStatus lockStat_;

//${QXK-impl::QF_SCHED_LOCK_} ................................................
#define QF_SCHED_LOCK_(ceil_) do { \
    if (QXK_ISR_CONTEXT_()) { \
        lockStat_ = 0xFFU; \
    } else { \
        lockStat_ = QXK_schedLock((ceil_)); \
    } \
} while (false)

//${QXK-impl::QF_SCHED_UNLOCK_} ..............................................
#define QF_SCHED_UNLOCK_() do { \
    if (lockStat_ != 0xFFU) { \
        QXK_schedUnlock(lockStat_); \
    } \
} while (false)

//${QXK-impl::QACTIVE_EQUEUE_WAIT_} ..........................................
#define QACTIVE_EQUEUE_WAIT_(me_) \
    Q_ASSERT_NOCRIT_(302, (me_)->eQueue.frontEvt != (QEvt *)0)

//${QXK-impl::QACTIVE_EQUEUE_SIGNAL_} ........................................
#ifndef Q_UNSAFE
#define QACTIVE_EQUEUE_SIGNAL_(me_) do { \
    QPSet_insert(&QXK_priv_.readySet, (uint_fast8_t)(me_)->prio); \
    QPSet_update_(&QXK_priv_.readySet, &QXK_priv_.readySet_dis); \
    if (!QXK_ISR_CONTEXT_()) { \
        if (QXK_sched_() != 0U) { \
            QXK_activate_(); \
        } \
    } \
} while (false)
#endif // ndef Q_UNSAFE

//${QXK-impl::QACTIVE_EQUEUE_SIGNAL_} ........................................
#ifdef Q_UNSAFE
#define QACTIVE_EQUEUE_SIGNAL_(me_) do { \
    QPSet_insert(&QXK_priv_.readySet, (uint_fast8_t)(me_)->prio); \
    if (!QXK_ISR_CONTEXT_()) { \
        if (QXK_sched_() != 0U) { \
            QXK_activate_(); \
        } \
    } \
} while (false)
#endif // def Q_UNSAFE

//${QXK-impl::QXTHREAD_EQUEUE_SIGNAL_} .......................................
#ifndef Q_UNSAFE
#define QXTHREAD_EQUEUE_SIGNAL_(me_) do { \
    if (me->super.temp.obj == QXK_PTR_CAST_(QMState*, &me->eQueue)) { \
        (void)QXThread_teDisarm_(QXTHREAD_CAST_(me)); \
        QPSet_insert(&QXK_priv_.readySet, (uint_fast8_t)me->prio); \
        QPSet_update_(&QXK_priv_.readySet, &QXK_priv_.readySet_dis); \
        if (!QXK_ISR_CONTEXT_()) { \
            (void)QXK_sched_(); \
        } \
    } \
} while (false)
#endif // ndef Q_UNSAFE

//${QXK-impl::QXTHREAD_EQUEUE_SIGNAL_} .......................................
#ifdef Q_UNSAFE
#define QXTHREAD_EQUEUE_SIGNAL_(me_) do { \
    if (me->super.temp.obj == QXK_PTR_CAST_(QMState*, &me->eQueue)) { \
        (void)QXThread_teDisarm_(QXTHREAD_CAST_(me)); \
        QPSet_insert(&QXK_priv_.readySet, (uint_fast8_t)me->prio); \
        if (!QXK_ISR_CONTEXT_()) { \
            (void)QXK_sched_(); \
        } \
    } \
} while (false)
#endif // def Q_UNSAFE

//${QXK-impl::QXK_PTR_CAST_} .................................................
#define QXK_PTR_CAST_(type_, ptr_) ((type_)(ptr_))

//${QXK-impl::QXTHREAD_CAST_} ................................................
#define QXTHREAD_CAST_(ptr_) ((QXThread *)(ptr_))

//${QXK-impl::QXK_threadExit_} ...............................................
//! @private @memberof QXK
//! @private @memberof QXK
void QXK_threadExit_(void);
//$enddecl${QXK-impl} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QF-QMPool-impl} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QF-QMPool-impl::QF_EPOOL_TYPE_} ..........................................
#define QF_EPOOL_TYPE_ QMPool

//${QF-QMPool-impl::QF_EPOOL_INIT_} ..........................................
#define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_) \
    (QMPool_init(&(p_), (poolSto_), (poolSize_), (evtSize_)))

//${QF-QMPool-impl::QF_EPOOL_EVENT_SIZE_} ....................................
#define QF_EPOOL_EVENT_SIZE_(p_) ((uint_fast16_t)(p_).blockSize)

//${QF-QMPool-impl::QF_EPOOL_GET_} ...........................................
#define QF_EPOOL_GET_(p_, e_, m_, qs_id_) \
    ((e_) = (QEvt *)QMPool_get(&(p_), (m_), (qs_id_)))

//${QF-QMPool-impl::QF_EPOOL_PUT_} ...........................................
#define QF_EPOOL_PUT_(p_, e_, qs_id_) \
    (QMPool_put(&(p_), (e_), (qs_id_)))
//$enddecl${QF-QMPool-impl} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

#endif // QP_IMPL

#endif // QXK_H_
