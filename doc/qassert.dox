/*! @file include/qassert.h
@brief QP Functional Safety (FuSa) Subsystem.

@details
This header file is part of the QP Functional Safety (FuSa) Subsystem and contains the following facilities:
- Software assertions (Failure Assertion Programming (FAP) in IEC 61508)
- Software Self-Monitoring (SSM) techniques:
  + Handling of Duplicate Inverse Storage
  + Handling of Memory Markers

@note
This header file can be used in C, C++, and mixed C/C++ programs.

@attention
The preprocessor switch #Q_UNSAFE disables the QP Functional Safety System. However, it is generally **NOT RECOMMENDED**, especially in the production code. Instead, the failure callback Q_onAssert() should be very carefully designed, implemented, and tested in various failure modes.
*/
//----------------------------------------------------------------------------
/*! @def Q_DEFINE_THIS_MODULE
Define the user-specified module name for assertions in this file.

@details
Macro to be placed at the top of each C/C++ module to define the single instance of the module name string to be used in reporting assertions in this module. This macro takes the user-supplied parameter `name_` instead of `__FILE__` to precisely control the name of the
module.

@param[in] name_ string constant representing the module name

@note
This macro should **not** be terminated by a semicolon.

@trace
- @tr{DVP-QP-PCLP-823}
*/
//----------------------------------------------------------------------------
/*! @def Q_ASSERT_INCRIT
General-purpose assertion with user-specified ID number (in critical section)

@param[in] id_   ID number (unique within the module) of the assertion
@param[in] expr_ Boolean expression to check

@attention
This macro must be called inside already established critical section. The evaluation of the expression `expr_` as well as calling of Q_onAssert() happens inside that critical section.

@attention
The assertion expression (`expr_`) must be possibly simple, have **no side effects**, and quick to evaluate because the evaluation happens inside a critical section. Also, the expression must **NOT** call any functions that might use critical sections inside (because this would cause nesting of critical sections, which might not be
supported).

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_ERROR_INCRIT
Assertion with user-specified ID for a wrong path through the code (in critical section)

@param[in] id_   ID number (unique within the module) of the assertion

@attention
This macro must be called inside already established critical section. The call to Q_onAssert() happens inside that critical section.

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_ASSERT_ID
General-purpose assertion with user-specified ID number.

@details
Evaluates the Boolean expression `expr_` and does nothing else when it evaluates to 'true'. However, when `expr_` evaluates to 'false', the Q_ASSERT_ID() macro calls the no-return function Q_onAssert().

@param[in] id_   ID number (unique within the module) of the assertion
@param[in] expr_ Boolean expression to check

@attention
This macro uses critical section and the evaluation of the expression `expr_` as well as calling of Q_onAssert() happens inside the critical section.

@attention
The assertion expression (`expr_`) must be possibly simple, have __no side effects__, and quick to evaluate because the evaluation happens inside a critical section. Also, the expression must __NOT__ call any functions that might use critical sections inside (because this would cause nesting of critical sections, which might not be supported).

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_ERROR_ID
Assertion with user-specified ID for a wrong path through the code

@details
Calls the Q_onAssert() callback if ever executed. This assertion takes the user-supplied parameter `id_` to identify the location of this assertion within the file. This avoids the volatility of using line numbers, which change whenever a line of code is added or removed
upstream from the assertion.

@param[in] id_   ID number (unique within the module) of the assertion

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_DEFINE_THIS_FILE
Define the file name (with `__FILE__`) for assertions in this file

@details
Macro to be placed at the top of each C/C++ module to define the single instance of the file name string to be used in reporting assertions in this module.

@note
The file name string literal is defined by means of the standard preprocessor macro `__FILE__`. However, please note that, depending on the compiler, the `__FILE__` macro might contain the whole path name to the file, which might be inconvenient to log assertions.

@attention
This macro should **not** be terminated by a semicolon.

 @trace
- @tr{DVP-QP-PCLP-823}
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_ASSERT
General-purpose assertion (with __LINE__ used as location in the file)

@details
Equivalent to Q_ASSERT_ID(), except it uses __LINE__ to identify the assertion within a file.

@param[in] expr_ Boolean expression to check

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_ERROR()
Assertion for a wrong path through the code

@details
Calls the Q_onAssert() callback if ever executed.

@note
This macro identifies the problem location with the line number, which might change as the code is modified.

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_REQUIRE_ID(id_, expr_)
Assertion for checking **preconditions** (with user-specified ID number).

@details
Equivalent to Q_ASSERT_ID(), except the name provides a better
documentation of the intention of this assertion.

@param[in] id_   ID number (unique within the module) of the assertion
@param[in] expr_ Boolean expression

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_REQUIRE(expr_)
Assertion for checking preconditions (based on __LINE__).

@details
Equivalent to Q_ASSERT(), except the name provides a better documentation of the intention of this assertion.

@param[in] expr_ Boolean expression

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_REQUIRE_INCRIT(id_, expr_)
Assertion for checking **preconditions** (in critical section)

@details
Equivalent to Q_ASSERT_INCRIT(), except the name provides a better documentation of the intention of this assertion.

@param[in] id_   ID number (unique within the module) of the assertion
@param[in] expr_ Boolean expression

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_ENSURE_ID(id_, expr_)
Assertion for checking postconditions (with user-specified ID number).

@details
Equivalent to Q_ASSERT_ID(), except the name provides a better documentation of the intention of this assertion.

@param[in] id_   ID number (unique within the module) of the assertion
@param[in] expr_ Boolean expression
*/
//----------------------------------------------------------------------------
/*! @def Q_ENSURE(expr_)
Assertion for checking postconditions.

@details
Equivalent to Q_ASSERT(), except the name provides a better documentation of the intention of this assertion.

@param[in] expr_ Boolean expression

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_ENSURE_INCRIT(id_, expr_)
Assertion for checking **postconditions** (in critical section)

@details
Equivalent to Q_ASSERT_INCRIT(), except the name provides a better documentation of the intention of this assertion.

@param[in] id_   ID number (unique within the module) of the assertion
@param[in] expr_ Boolean expression

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_INVARIANT_ID(id_, expr_)
Assertion for checking invariants (with user-specified ID number).

@details
Equivalent to Q_ASSERT_ID(), except the name provides a better documentation of the intention of this assertion.

@param[in] id_   ID number (unique within the module) of the assertion
@param[in] expr_ Boolean expression

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_INVARIANT
Assertion for checking invariants.

@details
Equivalent to Q_ASSERT(), except the name provides a better documentation of the intention of this assertion.

@param[in] expr_ Boolean expression

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @def Q_ASSERT_STATIC
Static (compile-time) assertion.

@details
This type of assertion deliberately causes a compile-time error when the `expr_` Boolean expression evaluates to FALSE. The macro exploits the fact that in C/C++ a dimension of an array cannot be negative. The compile-time assertion has no runtime side effects.

@param[in] expr_ Compile-time Boolean expression

@note
The static assertion macro is provided for backwards compatibility with older C standards. Newer C11 supports `_Static_assert()`, which should be used instead of Q_ASSERT_STATIC().

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
/*! @property Q_onAssert(char const * const module, int_t const id)
Callback function invoked after detecting an error (part of QP
Functional Safety (FuSa) Subsystem).

@details
This callback function needs to be defined in the application to perform any corrective action after an **unrecoverable error** has been detected. The Q_onAssert() function is the last line of defense after the system failure and its implementation should be very **carefully** designed and **tested** under various fault conditions, including but not limited to: stack overflow/corruption, calling Q_onAssert() from an ISR or other hardware exception, etc.

@param[in] module name of the file/module in which the assertion failed
                  (constant, zero-terminated C string)
@param[in] id     ID of the assertion within the module. This could
                  be a line number or a user-specified ID-number.

@returns
This callback function should **not return** (see #Q_NORETURN), as continuation after an unrecoverable error makes no sense.

@attention
Q_onAssert() must be called within a critical section (typically with interrupts **disabled**).

@note
During debugging, Q_onAssert() is an ideal place to put a breakpoint. For deployment, it is **NOT RECOMMENDED** to implement Q_onAssert() as an endless loop that ties up the CPU (denial of service).

Called by the following: Q_ASSERT_ID(), Q_ERROR_ID(), Q_REQUIRE_ID(), Q_ENSURE_ID(), Q_INVARIANT_ID() as well as: Q_ASSERT(), Q_ERROR(), Q_REQUIRE(), Q_ENSURE(), and Q_INVARIANT().
*/
//----------------------------------------------------------------------------
/*! @def Q_DIM
Helper macro to calculate static dimension of a 1-dim `array_`

@param array_ 1-dimensional array

@returns
The length of the array (number of elements it can hold)

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
//----------------------------------------------------------------------------
