/*! @file include/qequeue.h
@brief QP natvie, platform-independent, thread-safe event queue interface

@trace
- @tr{DVP-QP-MC4-D04_08}
*/
//----------------------------------------------------------------------------
/*! @def QF_EQUEUE_CTR_SIZE
The size [bytes] of the ring-buffer counters used in the native QF event queue implementation. Valid values: 1U, 2U, or 4U; default 1U.

@details
This macro can be defined in the QF port file (qf_port.h) to configure the ::QEQueueCtr type. Here the macro is not defined so the default of 1 byte is chosen.
*/
#define QF_EQUEUE_CTR_SIZE 1U
//----------------------------------------------------------------------------
/*! @typedef QEQueueCtr
The data type to store the ring-buffer counters based on the macro #QF_EQUEUE_CTR_SIZE.

@details
The dynamic range of this data type determines the maximum length of the ring buffer managed by the native QF event queue.
*/
typedef uint8_t QEQueueCtr;


//============================================================================
/*! @class QEQueue
@brief Native QF Event Queue

@details
This class describes the native QF event queue, which can be used as the event queue for active objects, or as a simple "raw" event queue for thread-safe event passing among non-framework entities, such as ISRs, device drivers, or other third-party components.

The native QF event queue is configured by defining the macro #QF_EQUEUE_TYPE as ::QEQueue in the specific QF port header file.

The ::QEQueue structure contains only data members for managing an event queue, but does not contain the storage for the queue buffer, which must be provided externally during the queue initialization.

The event queue can store only event pointers, not the whole events. The internal implementation uses the standard ring-buffer plus one external location that optimizes the queue operation for the most frequent case of empty queue.

The ::QEQueue structure is used with two sets of functions. One set is for the active object event queue, which might need to block the active object task when the event queue is empty and might need to unblock it when events are posted to the queue. The interface for the native active object
event queue consists of the following functions: QActive_post(), QActive_postLIFO(), and QActive_get_(). Additionally the function QEQueue_init() is used to initialize the queue.

The other set of functions, uses ::QEQueue as a simple "raw" event queue to pass events between entities other than active objects, such as ISRs. The "raw" event queue is not capable of blocking on the get() operation, but is still thread-safe because it uses QF critical section to protect its integrity. The interface for the "raw" thread-safe queue consists of the following functions: QEQueue_post(), QEQueue_postLIFO(), and QEQueue_get(). Additionally the function
QEQueue_init() is used to initialize the queue.

Most event queue operations (both the active object queues and the "raw" queues) internally use  the QF critical section. You should be careful not to invoke those operations from other critical sections when nesting of critical sections is not supported.

@sa ::QEQueue for the description of the data members
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::frontEvt
Pointer to event at the front of the queue.

@details
All incoming and outgoing events pass through the frontEvt location. When the queue is empty (which is most of the time), the extra frontEvt location allows to bypass the ring buffer altogether,
greatly optimizing the performance of the queue. Only bursts of events engage the ring buffer.

The additional role of this attribute is to indicate the empty status of the queue. The queue is empty when frontEvt is NULL.
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::ring
Pointer to the start of the ring buffer
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::end
Offset of the end of the ring buffer from the start of the buffer
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::head
Offset to where next event will be inserted into the buffer
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::tail
Offset of where next event will be extracted from the buffer
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::nFree
Number of free events in the ring buffer
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::nMin
Minimum number of free events ever in the ring buffer.

@details
This attribute remembers the low-watermark of the ring buffer, which provides a valuable information for sizing event queues.

@sa QF_getQueueMargin().
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::QEQueue_init(QEQueue * const me, QEvt const ** const qSto, uint_fast16_t const qLen)
Initialize the native QF event queue.

@details
Initialize the event queue by giving it the storage for the ring buffer.

@param[in,out] me   current instance pointer (see @ref oop)
@param[in] qSto     an array of pointers to ::QEvt to sereve as the
                    ring buffer for the event queue
@param[in] qLen     the length of the `qSto` buffer (in ::QEvt pointers)

@note The actual capacity of the queue is qLen + 1, because of the extra
location forntEvt.

@note
This function is also used to initialize the event queues of active objects in the built-int QV and QK kernels, as well as other QP ports to OSes/RTOSes that do provide a suitable message queue.
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::QEQueue_post(QEQueue * const me, QEvt const * const e, uint_fast16_t const margin, uint_fast8_t const qs_id)
Post an event to the "raw" thread-safe event queue (FIFO).

@details
Post an event to the "raw" thread-safe event queue using the First-In-First-Out (FIFO) order.

@param[in,out] me     current instance pointer (see @ref oop)
@param[in]     e      pointer to the event to be posted to the queue
@param[in]     margin number of required free slots in the queue after
                      posting the event. The special value #QF_NO_MARGIN
                      means that this function will assert if posting
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@returns 'true' (success) when the posting succeeded with the provided margin and 'false' (failure) when the posting fails.

@precondition{qf_qeq,200}
- event must be valid

@note
The #QF_NO_MARGIN value of the `margin` parameter is special and denotes situation when the post() operation is assumed to succeed (event delivery guarantee). An assertion fires, when the event cannot be delivered in this case.

@note This function can be called from any task context or ISR context.

@sa QEQueue_postLIFO(), QEQueue_get()
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::QEQueue_postLIFO(QEQueue * const me, QEvt const * const e, uint_fast8_t const qs_id)
Post an event to the "raw" thread-safe event queue (LIFO).

@details
Post an event to the "raw" thread-safe event queue using the Last-In-First-Out (LIFO) order.

@param[in,out] me  current instance pointer (see @ref oop)
@param[in]     e   pointer to the event to be posted to the queue
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@precondition{qf_qeq,300}
- the queue must be able to accept the event (cannot overflow)

@attention
The LIFO policy should be used only with great __caution__, because
it alters the order of events in the queue.

@note
This function can be called from any task context or ISR context.

@note
this function is used for the "raw" thread-safe queues and **not** for the queues of active objects.

@sa
QEQueue_post(), QEQueue_get(), QActive_defer()
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::QEQueue_get(QEQueue * const me, uint_fast8_t const qs_id)
Obtain an event from the "raw" thread-safe queue.

@details
Retrieves an event from the front of the "raw" thread-safe queue and returns a pointer to this event to the caller.

@param[in,out] me   current instance pointer (see @ref oop)
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@returns
pointer to event at the front of the queue, if the queue is not empty and NULL if the queue is empty.

@note
This function is used for the "raw" thread-safe queues and **not** for the queues of active objects.

@sa
QEQueue_post(), QEQueue_postLIFO(), QActive_recall()
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::QEQueue_getNFree(QEQueue const * const me)
Obtain the number of free entries still available in the queue.

@details
This operation needs to be used with caution because the number of free entries can change unexpectedly. The main intent for using this operation is in conjunction with event deferral. In this case the queue is accessed only from a single thread (by a single AO),  so the number of free
entries cannot change unexpectedly.

@param[in] me   current instance pointer (see @ref oop)

@returns the current number of free slots in the queue.
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::QEQueue_getNMin(QEQueue const * const me)
Obtain the minimum number of free entries ever in the queue (a.k.a. "low-watermark").

@details
This operation needs to be used with caution because the "low-watermark" can change unexpectedly. The main intent for using this operation is to get an idea of queue usage to size the queue adequately.

@param[in] me  current instance pointer (see @ref oop)

@returns the minimum number of free entries ever in the queue since init.
*/
//----------------------------------------------------------------------------
/*! @property QEQueue::QEQueue_isEmpty(QEQueue const * const me)
Find out if the queue is empty.

@details
This operation needs to be used with caution because the queue status can change unexpectedly. The main intent for using this operation is in conjunction with event deferral. In this case the queue is accessed only from a single thread (by a single AO), so no other entity can post events to the queue.

@param[in,out] me   current instance pointer (see @ref oop)

@returns 'true' if the queue is current empty and 'false' otherwise.
*/
//----------------------------------------------------------------------------
