/*! @file include/qep.h
@brief QEP/C platform-independent public interface.

@trace
- @tr{DVP-QP-MC4-D04_08}
*/
//----------------------------------------------------------------------------
/*! @def QP_VERSION
The current QP version as an unsigned number

@details
::QP_VERSION is a decimal constant, where XX is a 1-digit or 2-digit major version number, Y is a 1-digit minor version number, and Z is a 1-digit release number.
*/
//----------------------------------------------------------------------------
/*! @def QP_VERSION_STR
The current QP version as a zero terminated string literal.

@details
::QP_VERSION_STR is of the form "XX.Y.Z", where XX is a 1-or 2-digit
major version number, Y is a 1-digit minor version number, and Z is
a 1-digit release number.
*/
//----------------------------------------------------------------------------
/*! @def QP_RELEASE
Encrypted  current QP release (7.3.0) and date (2023-06-30)
*/
//----------------------------------------------------------------------------
/*! @typedef int_t
Alias for line numbers in assertions and return from QF_run()
*/
//----------------------------------------------------------------------------
/*! @typedef float32_t
Alias for IEEE 754 32-bit floating point number

@note
QP does not use floating-point types anywhere in the internal implementation, except in QS software tracing, where utilities for output of floating-point numbers are provided for application-specific trace records.
*/
//----------------------------------------------------------------------------
/*! @typedef float64_t
Alias for IEEE 754 64-bit floating point number

@note
QP does not use floating-point types anywhere in the internal
implementation, except in QS software tracing, where utilities for
output of floating-point numbers are provided for application-specific
trace records.
*/
//----------------------------------------------------------------------------
/*! @typedef QSignal
The signal of event ::QEvt

@details
The relationship between an event and a signal is as follows. A signal in UML is the specification of an asynchronous stimulus that triggers reactions, and as such is an essential part of an event. (The signal conveys the type of the occurrence--what happened?) However, an event can also contain additional quantitative information about the occurrence in form of event parameters.
*/
//----------------------------------------------------------------------------
/*! @def QEVT_MARKER
::QEvt memory marker (for internal integrity checks)

@details
The marker is implanted in bits 4:7 of QEvt::poolId_.
*/

//============================================================================
/*! @class QEvt
@brief Event class

@details
::QEvt represents events without parameters and serves as the base class
for derivation of events with parameters.

@trace
- @tr{REQ-QP-01_00}
- @tr{ARC-QP-02_10}

@usage
The following example illustrates how to add an event parameter by derivation of the ::QEvt class. Please note that the ::QEvt member super is defined as the FIRST member of the derived struct.
@code{c}
typedef struct {
    QEvt super; // <=== inherit QEvt

    uint8_t keyId; // ID of the key depressed
} CalcEvt;
@endcode
*/
//----------------------------------------------------------------------------
/*! @property QEvt::sig
Signal of the event.

@trace
- @tr{REQ-QP-01_20}
*/
//----------------------------------------------------------------------------
/*! @property QEvt::poolId_
Pool ID indicating which event pool it came from

@description
The 8-bit `poolId_` member stores the event-pool number (in bits 0:3) and the *memory marker* for integrity checking (in bits 4:7). In the special case of immutable events (not from event pools)
the event-pool number bits are 0.

@trace
- @tr{REQ-QP-01_30}
*/
//----------------------------------------------------------------------------
/*!  @property QEvt::refCtr_
Reference counter (for mutable events)

@trace
- @tr{REQ-QP-01_30}
*/
//----------------------------------------------------------------------------
/*! @property QEvt::QEvt_ctor(QEvt const me, enum_t const sig)
*
@param[in,out]  me  current instance pointer (see @ref oop)
@param[in]      sig signal of the event to initialize

@trace
- @tr{REQ-QP-01_40}
*/
//----------------------------------------------------------------------------
/*! @property QEvt::QEvt_verify_(QEvt const me)
Verify the memory marker in the event (QP FuSa Subsystem)

@param[in]  me  current instance pointer (see @ref oop)

@returns
'true' if this event passes the integrity check and 'false' otherwise.
*/

//============================================================================
/*! @typedef QState
Type returned from state-handler functions.
*/
//----------------------------------------------------------------------------
/*! @typedef QStateHandler
Pointer to a state-handler function.
*/
//----------------------------------------------------------------------------
/*! @typedef QActionHandler
Pointer to an action-handler function.
*/
//----------------------------------------------------------------------------
/*! @typedef QXThreadHandler
Pointer to an extended-thread handler function
*/
//----------------------------------------------------------------------------
/*! @struct QMState
@brief State object for the ::QMsm class (QM State Machine).

@details
This class groups together the attributes of a ::QMsm state, such as the parent state (state nesting), the associated state handler function and the exit action handler function. These attributes are used inside the QMsm::QMsm_dispatch_() and QMsm::QMsm_init_() implementations.

@trace
- @tr{REQ-QP-02_21}

@attention
The ::QMState class is only intended for the QM code generator and should not be used in hand-crafted code.
*/
//----------------------------------------------------------------------------
/*! @struct QMTranActTable
@brief Transition-Action Table for the ::QMsm State Machine.
*/
//----------------------------------------------------------------------------
/*! @union QAsmAttr
@brief Attribute of for the ::QAsm class (Abstract State Machine).
*
@details
This union represents possible values stored in the 'state' and 'temp' attributes of the ::QAsm class.

@trace
- @tr{DVP-QP-MC4-R19_02}
*/
//----------------------------------------------------------------------------
/*! @struct QAsmVtable
@brief Virtual table for the ::QAsm class.

@trace
- @tr{REQ-QP-02_10}
*/
//----------------------------------------------------------------------------
/*! @property QAsmVtable::init
Virtual function to take the top-most initial transition in the HSM.
*/
//----------------------------------------------------------------------------
/*! @property QAsmVtable::dispatch
Virtual function to dispatch an event to the HSM.
*/
//----------------------------------------------------------------------------
/*! @property QAsmVtable::getStateHandler
Virtual function to get the current state handler of the HSM.
*/

//============================================================================
/*! @class QAsm
@brief Abstract State Machine class (state machine interface)

@trace
- @tr{REQ-QP-02_00}
- @tr{REQ-QP-02_10}
*/
//----------------------------------------------------------------------------
/*! @property QAsm::vptr
Virtual pointer inherited by all QHsm subclasses (see also @ref oop).

@trace
- @tr{REQ-QP-02_10}
*/
//----------------------------------------------------------------------------
/*! @property QAsm::state
Current state (pointer to the current state-handler function)

@trace
- @tr{REQ-QP-02_10}
*/
//----------------------------------------------------------------------------
/*! @property QAsm::temp
Temporary storage for target/act-table, etc.

@details
The `temp` data member is used for passing information from the QP Application to the "event processor" of QP. The `temp` member is also used as a redundant copy of the `state` variable in between transitions (part of QP Functional Safety (FuSa) Subsystem).
*/

//============================================================================
/*! @class QHsm
@brief Hierarchical State Machine class (QHsm-style state machine implementation strategy)

@details
::QHsm represents a Hierarchical State Machine (HSM) with full support for hierarchical nesting of states, entry/exit actions, initial transitions, and transitions to history in any composite state. This class is designed for ease of manual coding of HSMs in C, but it is also supported by the QM modeling tool.

@note
::QHsm is not intended to be instantiated directly, but rather serves as the abstract base class for derivation of state machines in the QP application.

@trace
- @tr{REQ-QP-02_00}
- @tr{REQ-QP-02_10}
- @tr{ARC-QP-02_20}

@usage
The following example illustrates how to derive a state machine class from QHsm. Please note that the QHsm member `super` is defined as the FIRST member of the derived class.
@code{c}
typedef struct {
    QHsm super;  // <=== inherit QHsm

    double operand1;
    double operand2;
    char display[DISP_WIDTH + 1];
    uint8_t len;
    uint8_t opKey;
} Calc;
@endcode
*/
//----------------------------------------------------------------------------
/*! @property QHsm::QHsm_init_(QAsm const me, void const e, uint_fast8_t const qs_id)
Implementation of the top-most initial transition in ::QHsm.

@details
Synchronously executes the top-most initial transition in a state machine.

@param[in,out] me  current instance pointer (see @ref oop)
@param[in]     e   pointer to an extra parameter (might be NULL)
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@precondition{qep_msm,200}
- the virtual pointer must be initialized,
- the top-most initial transition must be initialized,
- the initial transition must not be taken yet.

@note
This function should be called only via the virtual table (see
QASM_INIT()) and should NOT be called directly in the applications.
*/
//----------------------------------------------------------------------------
/*! @property QHsm::QHsm_dispatch_(QAsm const me, QEvt const e, uint_fast8_t const qs_id)
Implementation of dispatching events to a ::QHsm

@details
Synchronously dispatches an event for processing to a state machine. The processing of an event represents one run-to-completion (RTC) step.

@param[in,out] me current instance pointer (see @ref oop)
@param[in]     e  pointer to the event to be dispatched to the MSM
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@precondition{qep_msm,302}
- current state must be initialized
- check the internal integrity (Software Self-Monitoring (SSM))

@note
This function should be called only via the virtual table (see QASM_DISPATCH()) and should NOT be called directly in the applications.
*/
//----------------------------------------------------------------------------
/*! @property QHsm::QHsm_getStateHandler_(QAsm const me)
Implementation of getting the state handler in a ::QHsm subclass

@param[in,out] me current instance pointer (see @ref oop)

@note
This function is only called internally via the virtual table
*/
//----------------------------------------------------------------------------
/*! @property QHsm::QHsm_isIn(QHsm const me, QStateHandler const state)
@details
Tests if a given state is part of the current active state configuration in ::QHsm subclasses.

@note For a HSM, to "be in a state" means also to be in a superstate of of the state.

@param[in] me    current instance pointer (see @ref oop)
@param[in] state pointer to the state-handler function to be tested

@returns 'true' if the HSM "is in" the `state` and 'false' otherwise

@precondition{qep_hsm,602}
- internal integrity check (Software Self-Monitoring (SSM))

@trace
- @tr{REQ-QP-02_25}
*/
//----------------------------------------------------------------------------
/*! @property QHsm::QHsm_state(QHsm const * const me)
Obtain the current active state from a MSM (read only)

@param[in] me     current instance pointer (see @ref oop)

@returns the current active state-handler

@note
This function is used in QM for auto-generating code for state history (deep history)
*/
//----------------------------------------------------------------------------
/*! @property QHsm::QHsm_childState(QHsm * const me, QStateHandler const parent)
Obtain the current active child state of a given parent in ::QMsm

@details
Finds the child state of the given `parent`, such that this child state is an ancestor of the currently active state. The main purpose of this function is to support **shallow history*transitions in state machines derived from QMsm.

@param[in] me     current instance pointer (see @ref oop)
@param[in] parent pointer to the state-handler

@returns
the child of a given `parent` state-handler, which is an ancestor of the currently active state. For the corner case when the currently active state is the given `parent` state, function returns the `parent` state.

@postcondition{qep_msm,890}
- the child must be found

@note
This function is used in QM for auto-generating code for state history (shallow history)
*/

//============================================================================
/*! @class QMsm
@brief Hierarchical State Machine class (QMsm-style state machine implementation strategy)

@details
QMsm (QM State Machine) provides a more efficient state machine implementation strategy than ::QHsm, but requires the use of the QM modeling tool, but are the fastest and need the least run-time support (the smallest event-processor taking up the least code space).

@note
QMsm is not intended to be instantiated directly, but rather serves as the abstract base class for derivation of state machines in the application code.

@trace
- @tr{REQ-QP-02_21}
- @tr{ARC-QP-02_40}

@usage
The following example illustrates how to derive a state machine class from QMsm. Please note that the QMsm member `super` is defined as the *first* member of the derived struct.
@code{c}
typedef struct {
    QMsm super; // <=== inherit QMsm

    double operand1;
    double operand2;
    char display[DISP_WIDTH + 1];
    uint8_t len;
    uint8_t opKey;
} Calc;
@endcode
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_init_(QAsm const me, void const e, uint_fast8_t const qs_id)
Implementation of the top-most initial transition in ::QMsm.

@details
Synchronously executes the top-most initial transition in a state machine.

@param[in,out] me  current instance pointer (see @ref oop)
@param[in]     e   pointer to an extra parameter (might be NULL)
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@precondition{qep_msm,200}
- the virtual pointer must be initialized,
- the top-most initial transition must be initialized,
- the initial transition must not be taken yet.

@note
This function should be called only via the virtual table (see
QASM_INIT()) and should NOT be called directly in the applications.
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_dispatch_(QAsm const me, QEvt const e, uint_fast8_t const qs_id)
Implementation of dispatching events to a ::QMsm

@details
Synchronously dispatches an event for processing to a state machine. The processing of an event represents one run-to-completion (RTC) step.

@param[in,out] me current instance pointer (see @ref oop)
@param[in]     e  pointer to the event to be dispatched to the MSM
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@precondition{qep_msm,302}
- current state must be initialized
- check the internal integrity (Software Self-Monitoring (SSM))

@note
This function should be called only via the virtual table (see QASM_DISPATCH()) and should NOT be called directly in the applications.
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_getStateHandler_(QAsm const me)
Implementation of getting the state handler in a ::QMsm subclass

@param[in,out] me current instance pointer (see @ref oop)

@note
This function is only called internally via the virtual table
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_isInState(QMsm const me, QMState const stateObj)
Tests if a given state is part of the current active state configuration in a MSM.

@details
Tests if a state machine derived from QMsm is-in a given state.

@note
For a HSM, to "be-in" a state means also to "be-in" a superstate of of the state.

@param[in] me    current instance pointer (see @ref oop)
@param[in] stateObj pointer to the QMState object that corresponds to the tested state.
@returns
'true' if the MSM "is in" the `state` and 'false' otherwise
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_stateObj(QMsm const me)
Obtain the current active state from a MSM (read only)

@param[in] me     current instance pointer (see @ref oop)

@returns the current active state-object

@note
This function is used in QM for auto-generating code for state history (deep history)
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_childStateObj(QMsm const * const me, QMState const * const parent)
Obtain the current active child state of a given parent in ::QMsm

@details
Finds the child state of the given @c parent, such that this child state is an ancestor of the currently active state. The main purpose of this function is to support **shallow history*transitions in state machines derived from QMsm.

@param[in] me     current instance pointer (see @ref oop)
@param[in] parent pointer to the state-handler object

@returns
the child of a given @c parent state, which is an ancestor of the currently active state. For the corner case when the currently active state is the given @c parent state, function returns the @c parent state.

@postcondition{qep_msm,890}
- the child must be found

@note
This function is used in QM for auto-generating code for state history (shallow history)
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_ctor(QMsm const me, QStateHandler const initial)
Constructor of ::QMsm

@details
Performs the first step of QMsm initialization by assigning the initial pseudostate to the currently active state of the state machine.

@param[in,out] me       current instance pointer (see @ref oop)
@param[in]     initial  the top-most initial transition for the MSM.

@note
Must be called only ONCE before QASM_INIT().

@usage
The following example illustrates how to invoke QMsm_ctor() in the
"constructor" of a derived state machine:
@code{c}
void Calc_ctor(Calc const me) {
    // call superclass' ctor
    QMsm_ctor(&me->super, Q_STATE_CAST(&Calc_initial));

    me->operand1 = 0.0;
    me->operand2 = 0.0;
    me->len      = 0U;
    me->opKey    = 0U;
}
@endcode
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_execTatbl_(QHsm const me, QMTranActTable const tatbl, uint_fast8_t const qs_id)
Execute transition-action table

@details
Helper function to execute transition sequence in a transition-action table.

@param[in,out] me    current instance pointer (see @ref oop)
@param[in]     tatbl pointer to the transition-action table
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@returns
status of the last action from the transition-action table.

@precondition{qep_msm,400}
- provided state table cannot be NULL

@note
This function is for internal use inside the QEP event processor and should **not* be called directly from the applications.
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_exitToTranSource_(QHsm const me, QMState const cs, QMState const ts, uint_fast8_t const qs_id)
Exit the current state up to the explicit transition source

@details
Static helper function to exit the current state configuration to the transition source, which in a hierarchical state machine might be a superstate of the current state.

@param[in,out] me   current instance pointer (see @ref oop)
@param[in]     cs   pointer to the current state
@param[in]     ts   pointer to the transition source state
@param[in]     qs_id QS-id of this state machine (for QS local filter)
*/
//----------------------------------------------------------------------------
/*! @property QMsm::QMsm_enterHistory_(QHsm const me, QMState const *const hist, uint_fast8_t const qs_id)
Enter history of a composite state

@details
Static helper function to execute the segment of transition to history after entering the composite state and

@param[in,out] me   current instance pointer (see @ref oop)
@param[in]     hist pointer to the history substate
@param[in]     qs_id QS-id of this state machine (for QS local filter)

@returns
#Q_RET_TRAN_INIT, if an initial transition has been executed in the last entered state or #Q_RET_NULL if no such transition was taken.
*/

//============================================================================
/*! @def QEVT_INITIALIZER
Initializer for immutable (constant) QEvt instances

@description
This macro encapsulates the ugly casting of enumerated signals and the generation of the memory marker for integrity check in `QEvt.poolId_`.

@usage
@code{c}
typedef struct {
    QEvt super;  // inherit QEvt
    uint8_t id;  // id of the pressed button
} ButtonPressEvt;
. . .
// immutable button-press event
static ButtonWorkEvt const pressEvt = {
    QEVT_INITIALIZER(BUTTON_PRESSED_SIG),
    .id = 123U
};
. . .
QACTIVE_POST(AO_Button, &pressEvt.super, &l_SysTick_Handler);
@endcode
*/
//----------------------------------------------------------------------------
/*! @def QEVT_POOLID_
* Provide quick access to POOLID member of event e
*
* @param[in]  e_  QEvt pointer
*
* @returns
* The event-pool number of a given event `e_`
*/
//----------------------------------------------------------------------------
/*! @def QASM_INIT
Virtual call to the top-most initial transition in a HSM.

@param[in,out] me_  current instance pointer (see @ref oop)
@param[in]  par_    pointer the optional initialization parameter
@param[in]  qs_id_  QS local filter ID (used only when Q_SPY is defined)

@note
Must be called only ONCE after the SM "constructor".

@trace
- @tr{REQ-QP-02_38}

@usage
The following example illustrates how to initialize a SM, and dispatch events to it:
@code{c}
#include "qpc.h"   // QP/C public interface
#include "calc.h"  // Calc derived from QHsm

Q_DEFINE_THIS_FILE

static Calc Calc_inst;  // an instance of Calc SM

int main() {
    Calc_ctor(&Calc_inst);  // Calc "constructor" invokes QHsm_ctor()

    QASM_INIT(&Calc_inst, (QEvt *)0); // <=== initial transition

    for (;;) { // event loop
        QEvt e = QEVT_INITIALIZER(MY_SIG);
        . . .
        // wait for the next event and assign it to the event object e
        . . .
        QASM_DISPATCH(&Calc_inst, &e); // dispatch e
    }
    return 0;
}
@endcode
*/
//----------------------------------------------------------------------------
/*! @def QASM_DISPATCH
Virtual call to dispatch an event to a HSM

@details
Processes one event at a time in Run-to-Completion fashion.

@param[in,out] me_ current instance pointer (see @ref oop)
@param[in]     e_  constant pointer the ::QEvt or a class derived from ::QEvt (see @ref oop)
@param[in]     qs_id_ QS local filter ID (used only when Q_SPY is defined)

@note Must be called after the "constructor" and after QASM_INIT().

@trace
- @tr{REQ-QP-02_10}

@usage
The following example illustrates how to initialize a SM, and dispatch events to it:
@code{c}
#include "qpc.h"   // QP/C public interface
#include "calc.h"  // Calc derived from QHsm

Q_DEFINE_THIS_FILE

static Calc Calc_inst;  // an instance of Calc SM

int main() {
    Calc_ctor(&Calc_inst);  // Calc "constructor" invokes QHsm_ctor()

    QASM_INIT(&Calc_inst, (QEvt *)0); // initial transition

    for (;;) { // event loop
        QEvt e = QEVT_INITIALIZER(MY_SIG);
        . . .
        // wait for the next event and assign it to the event object e
        . . .
        QASM_DISPATCH(&Calc_inst, &e); // <=== dispatch e
    }
    return 0;
}
@endcode
*/
//----------------------------------------------------------------------------
/*! @def Q_ASM_UPCAST
Perform upcasting from a subclass of ::QAsm to the base class ::QAsm

@remarks
Upcasting from a subclass to superclass is a very frequent and **safe** operation in object-oriented programming and object-oriented languages (such as C++) perform such upcasting automatically. However, OOP is implemented in C just as a set of coding conventions (see @ref oop), and the C compiler does not "know" that certain types are related by inheritance. Therefore for C, the upcast must be performed explicitly. Unfortunately, pointer casting violates the advisory MISRA-C:2023 Rule 11.3(R). This macro encapsulates this deviation and provides a descriptive name for the reason of this cast.

@param[in,out] ptr_ pointer to subclass of ::QAsm

@returns
The upcasted pointer to the ::QAsm base class

@trace
- @tr{DVP-QP-MC4-R11_03A} (upcast)
*/
//----------------------------------------------------------------------------
/*! @def Q_HSM_UPCAST
Perform upcasting from a subclass of ::QHsm to the base class ::QHsm

@sa
Q_ASM_UPCAST()

@param[in,out] ptr_ pointer to subclass of ::QHsm

@returns
The upcasted pointer to the ::QHsm base class

@trace
- @tr{DVP-QP-MC4-R11_03A} (upcast)
*/
//----------------------------------------------------------------------------
/*! @def Q_MSM_UPCAST
Perform upcasting from a subclass of ::QMsm to the base class ::QMsm

@sa
Q_ASM_UPCAST()

@param[in,out] ptr_ pointer to subclass of ::QMsm

@returns
The upcasted pointer to the ::QMsm base class

@trace
- @tr{DVP-QP-MC4-R11_03A} (upcast)
*/
//----------------------------------------------------------------------------
/*! @def Q_TRAN
Take transition to the specified `target_` state

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def Q_TRAN_HIST
Take transition to the specified history of a given state. Applicable only to HSMs.

@trace
- @tr{REQ-QP-02_39}
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R12_03}

@usage
@code{c}
typedef struct  {
    QHsm super;  // inherit QHsm

    QStateHandler hist_doorClosed; // history of doorClosed
} ToastOven;

QState ToastOven_doorClosed(ToastOven * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        . . .
        case Q_EXIT_SIG: {
            me->hist_doorClosed = QHsm_state(&me->super);
            status = Q_HANDLED();
            break;
        }
    }
    return status;
}

QState ToastOven_doorOpen(ToastOven * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        . . .
        case CLOSE_SIG: {
            status = Q_TRAN_HIST(hist_doorClosed); // <===
            break;
        }
        default: {
            status = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status;
}
@endcode
*/
//----------------------------------------------------------------------------
/*! @def Q_SUPER
Designates the superstate of a given state. Applicable only to ::QHsm subclasses.

@trace
- @tr{REQ-QP-02_31}
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}

@usage
@code{c}
QState Blinky_off(Blinky * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        case Q_ENTRY_SIG: {
            BSP_ledOff();
            status = Q_HANDLED();
            break;
        }
        case TIMEOUT_SIG: {
            status = Q_TRAN(&Blinky_on);
            break;
        }
        default: {
            status = Q_SUPER(&QHsm_top); // <===
            break;
        }
    }
    return status;
}
@endcode
*/
//----------------------------------------------------------------------------
/*! @def Q_HANDLED
Indicate that an action has been "handled". Applies to entry/exit actions and to internal transitions.

@trace
- @tr{REQ-QP-02_32}
- @tr{REQ-QP-02_33}
- @tr{REQ-QP-02_36}
*/
//----------------------------------------------------------------------------
/*! @def Q_UNHANDLED
Indicate that an internal transition has been "unhandled" due to a guard condition.

@details
This macro must be called when a state-handler attempts to handle an event but a guard condition evaluates to 'false' and there is no other explicit way of handling the event. Applicable only to ::QHsm subclasses.
*/
//----------------------------------------------------------------------------
/*! @def Q_ACTION_NULL
Macro to provide strictly-typed zero-action to terminate action lists in the transition-action-tables
*/
//----------------------------------------------------------------------------
/*! @def Q_EVT_CAST
Perform downcast of an event onto a subclass of ::QEvt `class_`

@details
This macro encapsulates the downcast of ::QEvt pointers, which violates MISRA-C:2023 Rule 11.3(R). This macro helps to localize this deviation.

@param class_  a subclass of ::QEvt

@trace
- @tr{REQ-QP-01_30}
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
- @tr{DVP-QP-MC4-R11_03B} (downcast)
- @tr{DVP-QP-PCLP-826}
*/
//----------------------------------------------------------------------------
/*! @def Q_STATE_CAST
Perform cast to ::QStateHandler.

@details
This macro encapsulates the cast of a specific state handler function pointer to ::QStateHandler, which violates MISRA:C-2023 Rule 11.1(R). This macro helps to localize this deviation.

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
- @tr{DVP-QP-MC4-R11_01}

@usage
@code{c}
void Philo_ctor(Philo * const me) {
    QActive_ctor(&me->super, Q_STATE_CAST(&Philo_initial)); // <===
    QTimeEvt_ctorX(&me->timeEvt, me, (enum_t)TIMEOUT_SIG, 0U);
}
@endcode
*/
//----------------------------------------------------------------------------
/*! @def Q_ACTION_CAST
Perform cast to ::QActionHandler.

@details
This macro encapsulates the cast of a specific action handler function pointer to ::QActionHandler, which violates MISRA:C-2023 Rule 11.1(R). This macro helps to localize this deviation.

@trace
- @tr{DVP-QP-MC4-D04_09A} (false-positive)
- @tr{DVP-QP-MC4-R11_01}
*/
//----------------------------------------------------------------------------
/*! @def Q_UNUSED_PAR
Helper macro to clearly mark unused parameters of functions.
*/
//----------------------------------------------------------------------------
/*! @def Q_DIM
Helper macro to calculate static dimension of a 1-dim `array_`

@param array_ 1-dimensional array

@returns the length of the array (number of elements it can hold)
*/
//----------------------------------------------------------------------------
/*! @def Q_UINT2PTR_CAST
Perform cast from unsigned integer `uint_` to pointer of type `type_`

@details
This macro encapsulates the cast to (type_ *), which QP ports or application might use to access embedded hardware registers. Such uses can trigger PC-Lint "Note 923: cast from int to pointer" and this macro helps to encapsulate this deviation.
*/
//----------------------------------------------------------------------------
/*! @def QM_ENTRY
Macro to call in a QM action-handler when it executes an entry action. Applicable only to ::QMsm subclasses.

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_EXIT
Macro to call in a QM action-handler when it executes an exit action. Applicable only to ::QMsm subclasses.

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_SM_EXIT
Macro to call in a QM submachine exit-handler. Applicable only to subclasses of ::QMsm.

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_TRAN
Macro to call in a QM state-handler when it executes a regular transition. Applicable only to ::QMsm subclasses.

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R11_03A} (upcast)
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_TRAN_INIT
Macro to call in a QM state-handler when it executes an initial transition. Applicable only to ::QMsm subclasses.

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R11_03A} (upcast)
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_TRAN_HIST
Macro to call in a QM state-handler when it executes a transition to history. Applicable only to ::QMsm subclasses.

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_TRAN_EP
Macro to call in a QM state-handler when it executes a transition to the submachine via an entry point.

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R11_03A} (upcast)
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_TRAN_XP
Macro to call in a QM state-handler when it executes a transition to exit point. Applicable only to ::QMsm subclasses.

@trace
- @tr{DVP-QP-MC4-R11_01}
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_HANDLED
Macro to call in a QM state-handler when it handled an event. Applicable only to ::QMsm subclasses.
*/
//----------------------------------------------------------------------------
/*! @def QM_UNHANDLED
Indicate that an internal transition has been "unhandled" due to a guard condition. Applicable only to ::QMsm subclasses.

@details
This macro must be called when a state-handler attempts to handle an event but a guard condition evaluates to 'false' and there is no other explicit way of handling the event.
*/
//----------------------------------------------------------------------------
/*! @def QM_SUPER
Macro to call in a QM state-handler when it designates the superstate to handle an event. Applicable only to QMSMs.
*/
//----------------------------------------------------------------------------
/*! @def QM_SUPER_SUB
Macro to call in a QM submachine-handler when it designates the host state to handle an event. Applicable only to subclasses of ::QMsm.

@trace
- @tr{DVP-QP-MC4-R12_03}
- @tr{DVP-QP-MC4-R13_04}
*/
//----------------------------------------------------------------------------
/*! @def QM_STATE_NULL
Macro to provide strictly-typed zero-state to use for submachines. Applicable to subclasses of ::QMsm.
*/
//----------------------------------------------------------------------------
